---
title: "K means final project"
author: "Elysa Strunin, Ekaterina Mikhailova, Shenrui Pan."
date: '1 ноября 2016 г '
output: html_document
---
We developed K means algorithm wich includes steps:
Step 1) Randomly assign center locations for each of k clusters
Step 2) Assign each data point to the cluster whose center is closest to that point
Step 3) Recalculate each cluster center as the mean location of all the points assigned to it.
Check to make sure each cluster has at least one point.
Repeat steps 2-3.
```{r}
data(wine, package="rattle")

#Remove column 1 from the analysis
wine <- wine[-1]

#####INITIAL PART (1 of 2): Random sampling, and cluster placement based on 
#the random sampling:
#Randomly assign 3 epicenters: create empty matrix:
K_means<-function(x,k){ 
  epicenters <- matrix(0, nrow=3, ncol=13)
  #Sample from each column to obtain an epicenter coordinate:
  #i is "k" in k-means
  set.seed(2016)
  for(i in 1:k) {
    for(j in 1:ncol(x)) {
      col_sample <- sample(x[,j], 1)
      epicenters[i,j] <- col_sample
    }
  }
  
  #Verified that the sample falls within each column range
  
  #calculate euclidean dist:
  #for every observation to each of the three clusters: 
  
  #initialize matrix for euclidean norms, 
  #plus a column for cluster assignment at time t,
  #plus a column for cluster assignment at time t+1:
  all_norms <- matrix(0, nrow=nrow(x), ncol=k+2)
  
  
  for(i in 1:k) {
    for(j in 1:nrow(x)) {
      e_dist <- dist(rbind(x[j,], epicenters[i,]), method = "euclidean")
      #put in 178x3 matrix (rows are obs, cols are e dists per epicenter)
      all_norms[j, i] <- e_dist
    }
  }
  #Verified that this calculation is correct
  
  #take the min of each row; assign that col as the cluster; put it in fourth 
  #col of all_norms
  for(i in 1:nrow(x)) {
    min_dist_index <- which.min(as.vector(all_norms[i, c(1:k)]))
    all_norms[i,k+1] <- min_dist_index
  }  
  
  #DELETE THIS?
  #verify that each cluster has at least one point
  #if ((length(which(all_norms[,4]==1)) > 0)&
  #    (length(which(all_norms[,4]==2)) > 0)&
  #    (length(which(all_norms[,4]==3)) > 0) ) {
  #Consider removing the print message
  #    print ("Each cluster has at least one point")
  #}
  
  ####SECOND PART (2 OF 2) THIS IS WHERE THE LOOP BEGINS, UNTIL NO CHANGE in cluster assignments
  
  #Start the repeat loop and test for identical outputs in past 2 iterations
  
  count <- 0
  
  repeat { count <- count + 1
  if  (identical(all_norms[,k+1], all_norms[,k+2])==TRUE) 
  {output <- all_norms[,k+1]
  print(output);
  break
  }else{
    
    #Recalculate the epicenters as the means per cluster
    #obtain the row numbers per 1,2,3
    #calculate the means per column using the original matrix
    #populate the epicenters matrix
    for(i in 1:k) {
      wines_per_cluster <- wine[all_norms[,k+1]==i, ]
      #take the transpose here to orient it correctly:
      column_means_per_cluster <- t(colMeans(wines_per_cluster))
      epicenters[i, ] <- column_means_per_cluster
    }
    
    #repopulate all_norms columns 1-3 by running the function again
    for(i in 1:k) {
      for(j in 1:nrow(x)) {
        e_dist <- dist(rbind(x[j,], epicenters[i,]), method = "euclidean")
        #put in 178x3 matrix (rows are obs, cols are e dists per epicenter)
        all_norms[j, i] <- e_dist
      }
    }
    
    #populate all_norms column 5
    #take the min of each row; assign that col as the cluster; put it in fifth 
    #col of all_norms
    for(i in 1:nrow(x)) {
      min_dist_index <- which.min(as.vector(all_norms[i, c(1:k)]))
      all_norms[i,k+2] <- min_dist_index
    }  
    
    #If each cluster DOESN'T have at least one point,
    for (i in 1:k){
    if ((length(which(all_norms[,k+2]==i)) > 0) == FALSE ) 
    {
      #then print the t-1 cluster assignments, which SHOULD have at least one pt per cluster
      output <- all_norms[,k+1]
      print(output); break
    } 
    }
    #if cols 4,5 of all_norms are NOT equal, move the most recent clusters over and loop again
    if ((identical(all_norms[,k+1], all_norms[,k+2]))==FALSE) 
    {
      all_norms[,k+1] <- all_norms[,k+2]
      all_norms[,k+2] <- NA
    } 
    
  }} 
}



K_means(wine,3)
```

